#!/usr/bin/python
import subprocess
import sys
class red():
  direccion={'ip':'','mascara':''}
  def __init__(self, ip,mascara='255.255.255.0'):
    self.direccion['mascara']=mascara
    self.direccion['ip']=ip

  def calculaNumeroHost(self):
    #declaracion de las variables.
    netID=""
    numHosts=0
    octetosCompletos=0
    #obtenemos la ip por octeto
    octetosIP=self.direccion['ip'].split('.')
    #obtenemos la mascara por octeto
    octetosMascara=self.direccion['mascara'].split('.')
    #iteramos los octetos de la mascara, mascara tiene un arreglo similar a OctetosMascara=['255','255','240','0']
    #En el for el valor de octetoActual tomara el valor correspondiente. 
    for octetoActual in  octetosMascara:
      #verificamos si octeto es igual a 255, se tiene que convertir a un entero para la igualdad.
      if int(octetoActual)==255:
        #la variable netID tomara los valores de 255 las veces que coincida, se iran guardando
        #de la siguiente manera 
        # netID='172.168.'
        netID=netID+octetosIP[octetosCompletos]+'.'
        #contador para saber cuantas veces entro
        octetosCompletos=octetosCompletos+1
        #next una vez esto hace un retorno a la siguiente iteracion de for.
        next
      else:
        # binarioActual=format(int(octetoActual),'08b')
        #en caso de que no sea 255 octetoActual ejecutara lo siguiente
        #Declaramos una variable de ceros a ocho dado que son los bits que necesitamos para cada octeto.
        ceros=8
        #iteraremos bit por bit del octeto que no es 255
        # obtendremos el octeto en binario para poder obtner 
        for digito in bin(int(octetosMascara[octetosCompletos]))[2:]:
          #cada vez que el digito sea igual a uno, le restaremos uno a la variable cero
          if digito=='1': ceros=ceros-1
          else: break
        ##
        #  una vez que termino el ciclo for obtenemos los ceros, es decir si tenemos 255.255.240.0 sabriamos que es 11111111.11111111.11110000
        #  la variable ceros tendra los ceros de la mascara de red a nivel de bits.
        #   con el ejemplo anterios ceros seria igual a cuatro.
        numHosts=2**((3-octetosCompletos)*8+ceros)-2
        # print numHosts
        ##
        #  netID anteriormente tenia las mascaras de 255, ahora le concatenaremos el resultado de la
        #   operacion de octetosIP[octetosCOmpletos] AND octetoActual
        #   es decir si la IP= 172.168.95.1 y mascara 255.255.240.0
        #   hara la operacoin de 95 AND 240, este resultado se lo concatenaara a netID
        #   dada la mascara anterior, netID tendria los siguiente valores:
        #      netID = '172.168'
        #   mas la concatenacion de la operacion quedaria asi,
        #      netID = '172.168.80'
        netID=netID+str(int(octetosIP[octetosCompletos]) & int(octetoActual))
        # print netID
        # print netID
        ##
        #  para completar los 4 octetos validamos que octetosCompletos sea 4,
        #   en caso de que no, haremos un while para que octetos tome el valor de 4,
        #    es decir octetos = 3 hara una corrida
        # print octetosCompletos
        while octetosCompletos<3:
          #agregaremos con ceros los octetos faltantes
          #en este caso octetosCompletos = 3, agregara un .0
          #quedando asi netID='172.168.80.0'
          netID=netID + '.0'
          # print netID
          ##
          #  suma uno a octetosCompletos, quedando con valor de 4.
          #
          octetosCompletos=octetosCompletos+1
        break
      #esta funcion regresara el numero de host y netID
    return numHosts,netID
  def generaListaHost(self):
    #declaramos un array de ips para las ip's
    ips=[]
    #se manda a llamar la funcion para obtner los host y netID
    numHosts,netID=self.calculaNumeroHost()
    ##
    #   netID tiene la forma de la ip, obtendremos sus octetos.
    red=netID.split('.')
    # print(red)

    #vamos a sacar todas las redes.
    while numHosts>0:
      #obtenemos la primer ip que sera 192.168.80.1
      red[3]=str( int(red[3])+1 )
      #la agregamos a nuestro array de IP's
      ips.append(red[0]+'.'+red[1]+'.'+red[2]+'.'+red[3])
      ##
      #   ahora verificamos  que la ip llegue a 255 y siga al sigueinte segmento,
      #   es decir al llegar ala ip 172.168.80.255
      #    detectara y saltara a la siguiente que es 172.168.81.0
      if red[3]=='255':
        if red[2]=='255':
          if red[1]=='255':
            red[0]=str(int(red[0])+1)
            red[1]='0'
            red[2]='0'
            red[3]='0'
          else:
            red[1]=str(int(red[1])+1)
          red[2]='0'
          red[3]='0'
        else:
          red[2]=str(int(red[2])+1)
        red[3]='0'
      # else:
      #   red[3]=str(int(red[1])+1)
      #restara uno numHost cada vez que va agregando uno a la variable ips
      numHosts=numHosts-1
    #regresara el arreglo de ips
    # print ips
    return ips
  def ping(self):
    for host in self.generaListaHost():
      cmd="ping -c 1 "+host
      p = subprocess.Popen(cmd,shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
      line= str(p.stdout.readlines())
      if line.find("+1 error") < 0:
        print "IP "+str(host)+" UP"

if len(sys.argv) == 2:
  host=str(sys.argv[1])
  escaneo=red(host)
elif len(sys.argv) == 3:
  host=str(sys.argv[1])
  netmask=str(sys.argv[2])
  escaneo=red(host,netmask)
else:
  print "  Error : "+str(sys.argv[0])+" host [netmask]"
  print "    host: IP a escanear"
  print "    netmask: Mascara de red"
  exit()

escaneo.ping()